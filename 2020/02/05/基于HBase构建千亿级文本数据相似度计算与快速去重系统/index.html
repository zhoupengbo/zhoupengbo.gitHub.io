<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"right","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言随着大数据时代的到来，数据信息在给我们生活带来便利的同时，同样也给我们带来了一系列的考验与挑战。本文主要介绍了基于 Apache HBase 与 Google SimHash 等多种算法共同实现的一套支持百亿级文本数据相似度计算与快速去重系统的设计与实现。该方案在公司业务层面彻底解决了多主题海量文本数据所面临的存储与计算慢的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="基于HBase构建千亿级文本数据相似度计算与快速去重系统">
<meta property="og:url" content="http://yoursite.com/2020/02/05/%E5%9F%BA%E4%BA%8EHBase%E6%9E%84%E5%BB%BA%E5%8D%83%E4%BA%BF%E7%BA%A7%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%8E%BB%E9%87%8D%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="漫泊今生 扶垚而上">
<meta property="og:description" content="前言随着大数据时代的到来，数据信息在给我们生活带来便利的同时，同样也给我们带来了一系列的考验与挑战。本文主要介绍了基于 Apache HBase 与 Google SimHash 等多种算法共同实现的一套支持百亿级文本数据相似度计算与快速去重系统的设计与实现。该方案在公司业务层面彻底解决了多主题海量文本数据所面临的存储与计算慢的问题。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-05T12:34:40.000Z">
<meta property="article:modified_time" content="2020-02-05T13:34:18.767Z">
<meta property="article:author" content="禅克">
<meta property="article:tag" content="love">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/02/05/%E5%9F%BA%E4%BA%8EHBase%E6%9E%84%E5%BB%BA%E5%8D%83%E4%BA%BF%E7%BA%A7%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%8E%BB%E9%87%8D%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>基于HBase构建千亿级文本数据相似度计算与快速去重系统 | 漫泊今生 扶垚而上</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?cb245b5fbb207868ecfcad91e5dd1f24";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">漫泊今生 扶垚而上</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-something">

    <a href="/something/" rel="section"><i class="fa fa-fw fa-gift"></i>有料</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-search">

    <a href="/search/" rel="section"><i class="fa fa-fw fa-search"></i>搜索</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/05/%E5%9F%BA%E4%BA%8EHBase%E6%9E%84%E5%BB%BA%E5%8D%83%E4%BA%BF%E7%BA%A7%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%8E%BB%E9%87%8D%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.jpg">
      <meta itemprop="name" content="禅克">
      <meta itemprop="description" content="你要成为一个什么样的人呢？">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漫泊今生 扶垚而上">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于HBase构建千亿级文本数据相似度计算与快速去重系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-05 20:34:40 / 修改时间：21:34:18" itemprop="dateCreated datePublished" datetime="2020-02-05T20:34:40+08:00">2020-02-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着大数据时代的到来，数据信息在给我们生活带来便利的同时，同样也给我们带来了一系列的考验与挑战。本文主要介绍了基于 Apache HBase 与 Google SimHash 等多种算法共同实现的一套支持百亿级文本数据相似度计算与快速去重系统的设计与实现。该方案在公司业务层面彻底解决了多主题海量文本数据所面临的存储与计算慢的问题。</p>
<a id="more"></a>

<h3 id="一-面临的问题"><a href="#一-面临的问题" class="headerlink" title="一. 面临的问题"></a>一. 面临的问题</h3><h4 id="1-如何选择文本的相似度计算或去重算法？"><a href="#1-如何选择文本的相似度计算或去重算法？" class="headerlink" title="1. 如何选择文本的相似度计算或去重算法？"></a>1. 如何选择文本的相似度计算或去重算法？</h4><p>常见的有余弦夹角算法、欧式距离、Jaccard 相似度、最长公共子串、编辑距离等。这些算法对于待比较的文本数据不多时还比较好用，但在海量数据背景下，如果每天产生的数据以千万计算，我们如何对于这些海量千万级的数据进行高效的合并去重和相似度计算呢？</p>
<h4 id="2-如何实现快速计算文本相似度或去重呢？"><a href="#2-如何实现快速计算文本相似度或去重呢？" class="headerlink" title="2. 如何实现快速计算文本相似度或去重呢？"></a>2. 如何实现快速计算文本相似度或去重呢？</h4><p>如果我们选好了相似度计算和去重的相关算法，那我们怎么去做呢？如果待比较的文本数据少，我们简单遍历所有文本进行比较即可，那对于巨大的数据集我们该怎么办呢？遍历很明显是不可取的。</p>
<h4 id="3-海量数据的存储与快速读写"><a href="#3-海量数据的存储与快速读写" class="headerlink" title="3. 海量数据的存储与快速读写"></a>3. 海量数据的存储与快速读写</h4><h3 id="二-SimHash-算法引入"><a href="#二-SimHash-算法引入" class="headerlink" title="二. SimHash 算法引入"></a>二. SimHash 算法引入</h3><p>基于问题一，我们引入了 SimHash 算法来实现海量文本的相似度计算与快速去重。下面我们简单了解下该算法。</p>
<h4 id="1-局部敏感哈希"><a href="#1-局部敏感哈希" class="headerlink" title="1. 局部敏感哈希"></a>1. 局部敏感哈希</h4><p>在介绍 SimHash 算法之前，我们先简单介绍下局部敏感哈希是什么。局部敏感哈希的基本思想类似于一种空间域转换思想，LSH 算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。</p>
<p> 局部敏感哈希的最大特点就在于保持数据的相似性，举一个小小的例子说明一下：对A文章微调后我们称其为B文章（可能只是多了一个‘的’字），如果此时我们计算两篇文章的 MD5 值，那么必将大相径庭。而局部敏感哈希的好处是经过哈希函数转换后的值也只是发生了微小的变化，即如果两篇文章相似度很高，那么在算法转换后其相似度也会很高。</p>
<p>MinHash 与 SimHash 算法都属于局部敏感哈希，一般情况若每个 Feature 无权重，则 MinHash 效果优于 SimHash 有权重时 SimHash 合适。长文本使用 Simhash 效果很好，短文本使用 Simhash 准备度不高。</p>
<h4 id="2-SimHash-算法"><a href="#2-SimHash-算法" class="headerlink" title="2. SimHash 算法"></a>2. SimHash 算法</h4><p>SimHash 是 Google 在2007年发表的论文《Detecting Near-Duplicates for Web Crawling 》中提到的一种指纹生成算法或者叫指纹提取算法，被 Google 广泛应用在亿级的网页去重的 Job 中，其主要思想是降维，经过simhash降维后，可能仅仅得到一个长度为32或64位的二进制由01组成的字符串。而一维查询则是非常快速的。</p>
<p>SimHash的工作原理我们这里略过，大家可以简单理解为：我们可以利用SimHash算法为每一个网页/文章生成一个长度为32或64位的二进制由01组成的字符串（向量指纹），形如：1000010010101101111111100000101011010001001111100001001011001011。</p>
<h4 id="3-海明距离"><a href="#3-海明距离" class="headerlink" title="3. 海明距离"></a>3. 海明距离</h4><p>两个码字的对应比特取值不同的比特数称为这两个码字的海明距离。在一个有效编码集中,任意两个码字的海明距离的最小值称为该编码集的海明距离。举例如下：10101和00110从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。</p>
<p>在 google 的论文给出的数据中，64位的签名，在海明距离为3的情况下，可认为两篇文档是相似的或者是重复的，当然这个值只是参考值。</p>
<p>这样，基于 SimHash 算法，我们就可以将百亿千亿级的高维特征文章转变为一维字符串后再通过计算其海明距离判断网页/文章的相似度，可想效率必将大大提高。</p>
<h3 id="三-效率问题"><a href="#三-效率问题" class="headerlink" title="三. 效率问题"></a>三. 效率问题</h3><p>到这里相似度问题基本解决，但是按这个思路，在海量数据几百亿的数量下，效率问题还是没有解决的，因为数据是不断添加进来的，不可能每来一条数据，都要和全库的数据做一次比较，按照这种思路，处理速度会越来越慢，线性增长。 </p>
<p>这里，我们要引入一个新的概念：<strong>抽屉原理</strong>，也称鸽巢原理。下面我们简单举例说一下：</p>
<p>桌子上有四个苹果，但只有三个抽屉，如果要将四个苹果放入三个抽屉里，那么必然有一个抽屉中放入了两个苹果。如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。</p>
<p>抽屉原理就是这么简单，那如果用它来解决我们海量数据的遍历问题呢？</p>
<p>针对海量数据的去重效率，我们可以将64位指纹，切分为4份16位的数据块，根据抽屉原理在海明距离为3的情况，如果两个文档相似，那么它必有一个块的数据是相等的。</p>
<p>那也就是说，我们可以以某文本的 SimHash 的每个16位截断指纹为 Key，Value 为 Key 相等时文本的 SimHash 集合存入 K-V 数据库即可，查询时候，精确匹配这个指纹的4个16位截断指纹所对应的4个 SimHash 集合即可。</p>
<p>如此，假设样本库，有2^37 条数据（1375亿数据），假设数据均匀分布，则每个16位（16个01数字随机组成的组合为2^16 个）倒排返回的最大数量为<br>(2^37) * 4 / (2^16) =8388608个候选结果，4个16位截断索引，总的结果为：4*8388608=33554432，约为3356万，通过<br>这样一来的降维处理，原来需要比较1375亿次，现在只需要比较3356万次即可得到结果，这样以来大大提升了计算效率。</p>
<p>根据网上测试数据显示，普通 PC 比较1000万次海明距离大约需要 300ms，也就是说3356万次（1375亿数据）只需花费3356/1000*0.3=1.0068s。那也就是说对于千亿级文本数据（如果每个文本1kb，约100TB数据）的相似度计算与去重工作我们最多只需要一秒的时间即可得出结果。</p>
<h3 id="四-HBase-存储设计"><a href="#四-HBase-存储设计" class="headerlink" title="四. HBase 存储设计"></a>四. HBase 存储设计</h3><p>饶了这么大一周，我们终于将需要讲明的理论知识给大家过了一遍。为了阐述的尽量清晰易懂，文中很多理论知识的理解借鉴了大量博主大牛的博客，原文链接已在文末附上，有不太明白的地方快快跪拜大牛们的博客吧，哈哈！</p>
<p>下面我们着重介绍一下 HBase 存储表的设计与实现。</p>
<p>基于上文我们可以大概知道，如果将64位指纹平分四份，海明距离取3，那么必有一段16位截取指纹的数据是相等的。而每一段16位截取指纹对应一个64位指纹集合，且该集合中的每个64位指纹必有一段16位截取指纹与该段16位截取指纹重合。我们可以简单表示(以8位非01指纹举例)为：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value(set)</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>[12345678,12345679]</td>
</tr>
<tr>
<td>23</td>
<td>[12345678,12345679,23456789]</td>
</tr>
</tbody></table>
<p>那如果基于 HBase 去实现的话，我们大概对比三种可能的设计方案。</p>
<h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>以 16 位指纹作为 HBase 数据表的行键，将每一个与之可能相似的64位指纹作为 HBase 的列，列值存文章id值，即构建一张大宽表。如下表所示(以8位非01指纹举例)：</p>
<table>
<thead>
<tr>
<th>rowkey</th>
<th>column1</th>
<th>column2</th>
<th>column3</th>
<th>…</th>
</tr>
</thead>
</table>
<p>实际数据表可能是这个样子：</p>
<table>
<thead>
<tr>
<th>rowkey</th>
<th>12345678</th>
<th>32234567</th>
<th>23456789</th>
<th>12456789</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>1102101</td>
<td></td>
<td></td>
<td>1102102</td>
<td>…</td>
</tr>
<tr>
<td>23</td>
<td></td>
<td>1102104</td>
<td>1102105</td>
<td></td>
<td>…</td>
</tr>
<tr>
<td>34</td>
<td>1102106</td>
<td></td>
<td></td>
<td></td>
<td>…</td>
</tr>
</tbody></table>
<p>那其实这样设计表的话该 HBase 表 Rowkey 的个数就是一个确定的数值：16个01数字随机组成的组合为2^16 个。也就是共2^16=65536行。 列的个数其实也是固定的，即2^64=184467440737亿万列。</p>
<p>此时，比如说我们比较56431234与库中所有文本的相似度，只需拉去rowkey in (56,43,12,34) 四行数据遍历每行列，由于 HBase 空值不进行存储，所有只会遍历存在值的列名。</p>
<p>由上文我们计算出1350亿数据如果平均分布的话每行大约有839万列，且不说我们的数据量可能远远大于千亿级别，也不说以64位字符串作为列名所占的存储空间有多大，单单千亿级数据量 HBase 每行就大约839万列，虽说HBase号称支持千万行百万列数据存储，但总归还是设计太不合理。数据不会理想化均匀分布，总列数高达184467440737亿万列也令人堪忧。</p>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>以 16 位指纹与64位指纹拼接后作为 HBase 数据表的行键，该表只有一列，列值存文章id值，即构建一张大长表。如下表所示(以8位非01指纹举例)：</p>
<table>
<thead>
<tr>
<th>rowkey</th>
<th>id</th>
</tr>
</thead>
</table>
<p>实际数据表可能是这个样子：</p>
<table>
<thead>
<tr>
<th>rowkey</th>
<th>id</th>
</tr>
</thead>
<tbody><tr>
<td>12_12345678</td>
<td>1</td>
</tr>
<tr>
<td>34_12345678</td>
<td>1</td>
</tr>
<tr>
<td>56_12345678</td>
<td>1</td>
</tr>
<tr>
<td>78_12345678</td>
<td>1</td>
</tr>
<tr>
<td>34_22345678</td>
<td>2</td>
</tr>
<tr>
<td>23_12235678</td>
<td>3</td>
</tr>
</tbody></table>
<p>如此设计感觉要比第一种方法要好一些，每一篇文章会被存为四行。但同样有诸多缺点，一是 Rowkey 过长，二是即便我们通过某种转变设计解决了问题一，那获取数据时我们也只能将 Get 请求转为四个Scan并发扫描+StartEnKey 去扫描表获取数据。当然，如果想实现顺序扫描还可能存在热点问题。在存储上，也造成了数据大量冗余。</p>
<h4 id="方案三："><a href="#方案三：" class="headerlink" title="方案三："></a>方案三：</h4><p>在真实生产环境中，我们采取该方案来避免上述两个方案中出现的问题与不足。下面简单介绍一下（如果您有更好更优的方案，欢迎留言，先表示感谢！）</p>
<p>简言之呢，就是自己在 HBase 端维护了一个 Set 集合（协处理器），并以 Json 串进行存储，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;64SimHash1&quot;:&quot;id1&quot;,</span><br><span class="line">    &quot;64SimHash2&quot;:&quot;id2&quot;,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于公司存在多种主题类型的文本数据，且互相隔离，去重与相似度计算也是分主题进行，我们的 Rowkey 设计大致如下：</p>
<p>Rowkey = HashNumber_ContentType_16SimHash  (共24位)</p>
<ul>
<li>HashNumber： 为防热点，对表进行Hash预分区（64个预分区），占2个字符<br>计算公式如下：String.format(“%02x”, Math.abs(key.hashCode()) % 64)</li>
<li>ContentType ：内容主题类型，占4个字符</li>
<li>16SimHash： 16位 SimHash 截取指纹，由01组成</li>
</ul>
<p>表结构大致如下：</p>
<table>
<thead>
<tr>
<th>rowkey</th>
<th>si</th>
<th>s0</th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>01_news_010101010101010101</td>
<td>value</td>
<td>1</td>
<td>Json 串</td>
<td></td>
<td></td>
<td>…</td>
</tr>
<tr>
<td>02_news_010101010101010110</td>
<td>value</td>
<td>2</td>
<td>Json 串</td>
<td>Json 串</td>
<td></td>
<td>…</td>
</tr>
<tr>
<td>03_news_100101010101010110</td>
<td>value</td>
<td>3</td>
<td>Json 串</td>
<td>Json 串</td>
<td>Json 串</td>
<td>…</td>
</tr>
<tr>
<td>01_xbbs_010101010101010101</td>
<td>value</td>
<td>1</td>
<td>Json 串</td>
<td></td>
<td></td>
<td>…</td>
</tr>
</tbody></table>
<p>si：客户端传递过来的欲存储的值，由64位 Simhash 与 Id 通过双下划线拼接而成，诸如 Simhash__Id 的形式。<br>s0：记录该行数据共有多少个 Set 集合，每一个 Set 集合存储10000个K-V对儿（约1MB）。<br>s1：第一个 Set 集合，Json 串存储，如果 Size &gt; 10000 ，之后来的数据将存入s2。<br>s2：以此类推。</p>
<p>当然最核心的部分是s1/s2/s3 中 Json 串中要排重。最简单的办法无非是每次存入数据前先将所有 Set 集合中的数据读到客户端，将欲存的数据与集合中所有数据比对后再次插入。这将带来大量往返IO开销，影响写性能。因此，我们在此引入了 HBase 协处理器技术来规避这个问题，即在服务端完成所有排重操作。大致代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.share.scenarios.observers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.google.gson.Gson;</span><br><span class="line">import com.google.gson.JsonObject;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.apache.hadoop.hbase.Cell;</span><br><span class="line">import org.apache.hadoop.hbase.CellUtil;</span><br><span class="line">import org.apache.hadoop.hbase.CoprocessorEnvironment;</span><br><span class="line">import org.apache.hadoop.hbase.client.Durability;</span><br><span class="line">import org.apache.hadoop.hbase.client.Get;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.client.Result;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.ObserverContext;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;</span><br><span class="line">import org.apache.hadoop.hbase.regionserver.wal.WALEdit;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  基于协处理器构建百亿级文本去重系统</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HBaseSimHashSetBuildSystem extends BaseRegionObserver &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(HBaseSimHashSetBuildSystem.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start(CoprocessorEnvironment e) throws IOException &#123;</span><br><span class="line">        logger.info(&quot;Coprocessor opration start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param e</span><br><span class="line">     * @param put</span><br><span class="line">     * @param edit</span><br><span class="line">     * @param durability</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void prePut(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Put put, WALEdit edit, Durability durability) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; test flag</span><br><span class="line">        logger.info(&quot;do something before Put Opration...&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Cell&gt; cells &#x3D; put.get(Bytes.toBytes(&quot;f&quot;), Bytes.toBytes(&quot;si&quot;));</span><br><span class="line">        if (cells &#x3D;&#x3D; null || cells.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String simhash__itemid &#x3D; Bytes.toString(CellUtil.cloneValue(cells.get(0)));</span><br><span class="line">        if (StringUtils.isEmpty(simhash__itemid)||simhash__itemid.split(&quot;__&quot;).length!&#x3D;2)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String simhash &#x3D; simhash__itemid.trim().split(&quot;__&quot;)[0];</span><br><span class="line">        String itemid &#x3D; simhash__itemid.trim().split(&quot;__&quot;)[1];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取Put Rowkey</span><br><span class="line">        byte[] row &#x3D; put.getRow();</span><br><span class="line">        &#x2F;&#x2F; 通过Rowkey构造Get对象</span><br><span class="line">        Get get &#x3D; new Get(row);</span><br><span class="line">        get.setMaxVersions(1);</span><br><span class="line">        get.addFamily(Bytes.toBytes(&quot;f&quot;));</span><br><span class="line">        Result result &#x3D; e.getEnvironment().getRegion().get(get);</span><br><span class="line">        Cell columnCell &#x3D; result.getColumnLatestCell(Bytes.toBytes(&quot;f&quot;), Bytes.toBytes(&quot;s0&quot;)); &#x2F;&#x2F; set size</span><br><span class="line">        if (columnCell &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 第一次存储数据，将size初始化为1</span><br><span class="line">            logger.info(&quot;第一次存储数据，将size初始化为1&quot;);</span><br><span class="line"></span><br><span class="line">            JsonObject jsonObject &#x3D; new JsonObject();</span><br><span class="line">            jsonObject.addProperty(simhash,itemid);</span><br><span class="line">            Gson gson &#x3D; new Gson();</span><br><span class="line">            String json &#x3D; gson.toJson(jsonObject);</span><br><span class="line"></span><br><span class="line">            put.addColumn(Bytes.toBytes(&quot;f&quot;),Bytes.toBytes(&quot;s1&quot;), Bytes.toBytes(json)); &#x2F;&#x2F; json 数组</span><br><span class="line">            put.addColumn(Bytes.toBytes(&quot;f&quot;),Bytes.toBytes(&quot;s0&quot;), Bytes.toBytes(&quot;1&quot;));  &#x2F;&#x2F; 初始化</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            byte[] sizebyte &#x3D; CellUtil.cloneValue(columnCell);</span><br><span class="line">            int size &#x3D; Integer.parseInt(Bytes.toString(sizebyte));</span><br><span class="line">            logger.info(&quot;非第一次存储数据 ----&gt; Rowkey &#96;&quot;+Bytes.toString(row)+&quot;&#96; simhash set size is : &quot;+size +&quot;, the current value is : &quot;+simhash__itemid);</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">                Cell cell1 &#x3D; result.getColumnLatestCell(Bytes.toBytes(&quot;f&quot;), Bytes.toBytes(&quot;s&quot;+i));</span><br><span class="line">                String jsonBefore &#x3D; Bytes.toString(CellUtil.cloneValue(cell1));</span><br><span class="line">                Gson gson &#x3D; new Gson();</span><br><span class="line">                JsonObject jsonObject &#x3D; gson.fromJson(jsonBefore, JsonObject.class);</span><br><span class="line">                int sizeBefore &#x3D; jsonObject.entrySet().size();</span><br><span class="line">                if(i&#x3D;&#x3D;size)&#123;</span><br><span class="line">                    if(!jsonObject.has(simhash))&#123;</span><br><span class="line">                        if (sizeBefore&#x3D;&#x3D;10000)&#123;</span><br><span class="line">                            JsonObject jsonone &#x3D; new JsonObject();</span><br><span class="line">                            jsonone.addProperty(simhash,itemid);</span><br><span class="line">                            String jsonstrone &#x3D; gson.toJson(jsonone);</span><br><span class="line">                            put.addColumn(Bytes.toBytes(&quot;f&quot;),Bytes.toBytes(&quot;s&quot;+(size+1)), Bytes.toBytes(jsonstrone)); &#x2F;&#x2F; json 数组</span><br><span class="line">                            put.addColumn(Bytes.toBytes(&quot;f&quot;),Bytes.toBytes(&quot;s0&quot;), Bytes.toBytes((size+1)+&quot;&quot;));  &#x2F;&#x2F; 初始化</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            jsonObject.addProperty(simhash,itemid);</span><br><span class="line">                            String jsonAfter &#x3D; gson.toJson(jsonObject);</span><br><span class="line">                            put.addColumn(Bytes.toBytes(&quot;f&quot;),Bytes.toBytes(&quot;s&quot;+size), Bytes.toBytes(jsonAfter)); &#x2F;&#x2F; json 数组</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(!jsonObject.has(simhash))&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，当我们需要对某一文本指纹与库中数据进行比对时，只需一个Table.Get(List<Get>) 操作即可返回所有的数据，然后基于s0依次获取各个 Set 集合中的数据即可。</p>
<p>下面我们算一笔账，假设我们某主题类型数据依然有 2^37 条数据（1375亿数据），假设数据均匀分布，则每个16位（16个01数字随机组成的组合为2^16 个）倒排返回的最大数量为 (2^37) * 4 / (2^16) =8388608个候选结果，即每行约839个 Set 集合，每个Set 集合大约1M 的话，数据存储量也必然不会太大。</p>
<p>你如果有十种不同主题的数据，HBase 行数无非也才 (2^16)*10 = 655360 行而已。</p>
<p>如果再加上 Snappy 压缩呢？<br>如果再加上 Fast-Diff 编码呢？<br>如果再开启 Mob 对象存储呢？ 每个 Set 是不是可以存10万个键值对？每行只需90个 Set 集合。</p>
<p>也或许，如果数据量小的话，使用 Redis 是不是更好呢？</p>
<p>总之，优化完善和不完美的地方还很多，本文也就简单叙述到此，如果您有好的建议或是不同看法，欢迎留言哦！感恩~ 晚安各位~~</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/u010454030/article/details/49102565" target="_blank" rel="noopener">1. https://blog.csdn.net/u010454030/article/details/49102565</a><br><a href="http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity2-html.html" target="_blank" rel="noopener">2. http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity2-html.html</a><br><a href="https://cloud.tencent.com/developer/news/218062" target="_blank" rel="noopener">3. https://cloud.tencent.com/developer/news/218062</a><br><a href="https://blog.csdn.net/qq_36142114/article/details/80540303" target="_blank" rel="noopener">4. https://blog.csdn.net/qq_36142114/article/details/80540303</a><br><a href="https://blog.csdn.net/u011467621/article/details/49685107" target="_blank" rel="noopener">5. https://blog.csdn.net/u011467621/article/details/49685107</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/02/05/Apache-Kylin-1.0%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/" rel="next" title="Apache Kylin 1.0中的混合模型">
      Apache Kylin 1.0中的混合模型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一-面临的问题"><span class="nav-number">2.</span> <span class="nav-text">一. 面临的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-如何选择文本的相似度计算或去重算法？"><span class="nav-number">2.1.</span> <span class="nav-text">1. 如何选择文本的相似度计算或去重算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-如何实现快速计算文本相似度或去重呢？"><span class="nav-number">2.2.</span> <span class="nav-text">2. 如何实现快速计算文本相似度或去重呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-海量数据的存储与快速读写"><span class="nav-number">2.3.</span> <span class="nav-text">3. 海量数据的存储与快速读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-SimHash-算法引入"><span class="nav-number">3.</span> <span class="nav-text">二. SimHash 算法引入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-局部敏感哈希"><span class="nav-number">3.1.</span> <span class="nav-text">1. 局部敏感哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-SimHash-算法"><span class="nav-number">3.2.</span> <span class="nav-text">2. SimHash 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-海明距离"><span class="nav-number">3.3.</span> <span class="nav-text">3. 海明距离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-效率问题"><span class="nav-number">4.</span> <span class="nav-text">三. 效率问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-HBase-存储设计"><span class="nav-number">5.</span> <span class="nav-text">四. HBase 存储设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方案一："><span class="nav-number">5.1.</span> <span class="nav-text">方案一：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方案二："><span class="nav-number">5.2.</span> <span class="nav-text">方案二：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方案三："><span class="nav-number">5.3.</span> <span class="nav-text">方案三：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">6.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="禅克"
      src="/images/avatar2.jpg">
  <p class="site-author-name" itemprop="name">禅克</p>
  <div class="site-description" itemprop="description">你要成为一个什么样的人呢？</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhoupengbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhoupengbo" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhoupengbo0413@163.com" title="E-Mail → mailto:zhoupengbo0413@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">禅克</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
